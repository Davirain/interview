# 王道程序员面试宝典

**全局（静态）存储区：**存放全局变量和静态变量。包括DATA段（全局初始化区）与BSS段（全局未初始化区）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和未初始化的静态变量存放在BSS段。程序结束后由系统释放。

​	其中BSS 段的特点是：在程序执行之前BSS段会自动清0，所以，未初始化的全局变量与静态变量在程序执行之前已经成0了。

**文字常量区:**常量字符串存放在这。程序结束后由系统释放。

**程序代码区：**存放函数体的二进制代码。

```c++
int k = 1;
void main()
{
    int i = 1;
    char * j;
    static int m = 1;
    char *n = "hello";/*变量n位于栈上，其内容为一地址，指向位于文字常量区的"hello", 此时”hello"在内存中只有一份拷贝；而语句“char a[] = "hello";” ，则不同，a是一个位于栈上的6个元素（含字符串末尾的空字符）的数组，并将"hello"拷贝到它所占的内存中，此时”hello"有两份拷贝。*/
    printf("栈区地址为：0X%x\n", &i);
    j = (char*)malloc(2);
    free(j);//及时释放
    printf("堆区地址为:0X%x\n", j);
    printf("全局变量地址为:0X%x\n", &k);
    printf("静态变量地址为:0X%x\n", &m);
    printf("文字常量区地址为:0X%x\n", n);
    printf("程序区地址为:%X%x\n", &main);
}
```

数组定义中类型不能是引用，即没有引用数组，这是因为引用是不能赋值的，而数组中的元素必须是可以被赋值的。

**一维数组的初始化**

​	1.函数体外定义的内置类型数组（即内置类型的全局数组），元素初始化化为0

​	2.函数体内定义的内置类型数组，元素无初始化（**注意：若只初始化部分元素，其后的元素此时也会被初始化为0**）；

​	3.如果不是内置类型，则不管其定义在那定义，自动调用默认构造函数为其初始化，若该类无默认构造函数则会报错。

 **字符数组**

​	字符数组既可以用一组花括号括起来、逗号隔开的字符常量进行初始化，也可以用一个常量字符串（末尾有空字符串）进行初始化。**注意：这两种初始化形式不完全相同，因为字符串常量包含一个额外的空字符用于结束字符串，当使用字符串常量值来初始化创建的新数组时，将在新数组末尾加入空字符。**

c/c++中的字符处理函数，传递给这些标准库函数例程的指针必须具有非零值，并且指向以**null结束的字符数组**中的第一个元素。

注意，在声明更高维数组时，也只有第一维可以省略。

逗号运算符：多个表达式可以用逗号分开，其中逗号分开的表达式的值分别计算，但整个表达式的值是最后一个表达式的值。

二维数组元素$a[x][y]在一维数组b中，$ $a[x][y] = b[x*列数+y]$

![1564934671141](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1564934671141.png)

__二维数组的动态声明__

```c
int **a = new int*[m];
for(int i = 0; i < m; i++)
    a[i] = new int [n];
```

就相当于产生了一个二维数组$a[m][n]$.

静态声明的数组可以有公式：$b[i][j] = b[i*n+j]$

这是因为数组b是连续的一片内存，而动态声明的数组任意的a[k]都是一个int* 类型，即一个地址，所以只能$a[i][j]或者*(*(a+i)+j)$来访问数组的元素，而不能$a[i*n+j]$这样使用。

动态声明的数组，使用后需要释放内存，操作如下：

```c
for(int i = 0; i < m; ++i)
    delete [] a[i];
delete []a;
```

__三种方法动态申请动态__

1. malloc/free
2. new/delete
3. vector

```c
/***malloc/free****/
// 动态申请一维数组
int *p = (int*)malloc(sizeof(int)*m);
free(p);
// 动态申请二位数组
int **p = (int**)malloc(sizeof(int*)*m);//开辟行
for(int i = 0; i < k; i++)
    *(p+i) = (int*)malloc(sizeof(int)*n);//开辟列
//释放开辟的二位数组
for(int i = 0; i < m; i++)
    free(*(p+i));

/*******new/free 见上************/

/***vector******/
vector<vector<int>> arr(m, vector<int>(n));
```

__指针运算 - 算术运算， 关系运算__

指针与整数的加减（包括指针的自增和自减），同类型指针间的比较，同类型的两个指针相减。

c的指针算术运算只局限于两种形式。

第一种形式：指针+/-整数。适用于指向数组中某个元素的指针。

第二种形式：指针-指针，只有当两个指针都指向同一个数组中方元素时， 才允许从一个指针减去另一个指针。

```c
//一维数组元素清理0
#define N_VALUES 6
float values[N_VALUES];
float * vp;
for(vp = &values[0]; vp < &values[N_VALUES];)
    *vp++ = 0;
```

__指针数组与数组指针__

指针数组，是指一个数组里面装着指针， 也即指针数组是一个数组， 一个有10个指针的数组，其中每个指针是指向一个整型数，

```
int * a[10];
```

​	

```c
int (*p)[10];
//由于[]的优先级高于*, 所以必须添加(*p);
```

二维数组的数组名是一个数组指针，

```c
int a[4][10];
int (*p)[10];
p = a;//a的类型是int(*)[10];
```

__指针数组与数组指针主要看后面两个字是什么（前两个字起修饰作用），指针数组是数组， 而数组指针是指针。__

```c
//example 1 下述代码是否正确？
char a[] = "hello";
a[0] = 'x';
char *q = a;
a[0] = 'b';
char *p = "hello";/*并不是把整个字符串装入指针变量，而是把存放该字符串的首地址装入指针变量*/
p[0] = 'x';
//answer:最有一个语句错误。a是数组， 内存分配在栈上，顾可以通过数组名或指向数组的指针进行修改，而p指向的位于文字常量区的字符串，是不允许被修改的，故通过指针修改错误，但是使用p[0]访问相应元素是正确的，只是不能修改。
```

![1564972780543](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1564972780543.png)

__数组的首地址是常量，不可以进行赋值操作。__

当数组作为函数参数传递时， 传递给函数的数组首元素的地址。而将数组某一个元素的地址当作实参时，传递的是此元素的地址，这时可以理解为传递的是子数组（以此元素作为首元素的子数组）首元素的地址。

![1564973404357](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1564973404357.png)

&a的类型为$int(*)[4][5]$

a+i的类型为$int(*)[5]$

$*(a+i)$的类型为$int*$

$*(*(a+i) + j)$的类型为int

$*(a+i) = a[i];$

$*(*(a+i) + j) = *(a[i]+j) = a[i][j]$

