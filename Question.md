## c++ 规定构造函数不能是虚函数，而析构函数可以是虚函数

理解：假设构造函数是一个虚函数，而虚函数的调用需要虚表，虚表又是由构造函数建立，

这样就会产生矛盾。


虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态成员函数。

## 静态成员

1 静态成员不属于对象， 是类的共享成员，而this是当前对象的指针，所以静态成员没有this指针

2 静态成员在类内声明，在类外定义初始化，

**为何？

因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象那个都包含该静态成员，这是矛盾的**

3 静态成员函数不拥有this指针，需要通过类参数访问对象成员。


## *p++ 和 (*p)++ 的区别

*p++的作用是：先解引用，获得p所指向的值，然后将p++,

即p指向下一位。

(*p)++的作用是：解引用，获得p所指向的值，然后将指向的值自加，

指针不发生移动。

## 注： printf从右边到左边执行操作。

## 友元函数

友元函数，不是类的成员函数，不需要类作用域符来表示该函数属于哪个类

## gets fgets getc fgetc

gets函数是读取字符串，以回车键结束

fgets是读取一行字符，以换行符结束

getc读入一个字符

fgetc读取一个字符，读取一个字节后后移一位

## c++类的数据成员的存储类型 不能是auto register 和 extern

auto\register\extern表示的是变量的存储位置和作用域

auto变量存储在函数的堆栈空间，register存储在寄存器，extern表示这里没有新定义变量

只是扩展了一个已有全局变量的作用域，类和结构体中的变量是成员变量，

其存储位置和作用域由定义对象的函数决定，不由这些对象自己决定。

## 运算符的优先级

-> 的优先级高于++的

优先级 【高低】

第一级：圆括号【()】、 下标运算符【[]】、分量运算符的指向结构体成员运算符【->】、结构体成员运算符【.】

第二级：逻辑非运算符【 ! 】、 按位取反运算符【 ~ 】 、自增自减运算符【 ++/-- 】、 负号运算符【 - 】、 类型转换运算符 【 (类型) 】、指针运算符和取地址运算符 【*和&】、长度运算符 【sizeof】 

第三级：乘法运算符【 * 】 、除法运算符【 / 】 、取余运算符【 % 】

第四级： 加法运算符【 + 】 、减法运算符【 - 】

第五级： 左移运算符 【<<】 、右移运算符【 >>】

第六级： 关系运算符【 < > <= >=】

第七级：等于运算符【==】 、不等于运算符【 !=】 

第八级：按位与运算符 【&】

第九级： 按位异或运算符【 ^】

第十级： 按位或运算符【 |】

第十一级：逻辑与运算符 【&&】

第十二级： 逻辑或运算符 【||】

第十三级： 条件运算符 【? :】

第十四级： 复制运算符 【= += -= *= /= %= >>= <<= &= |= ^=】

第十五级: 逗号运算符【,】

## 构造函数可以是内联函数

## 若a是float型变量，b是unsigned型变量。合法的是

scanf("%f%n",&a, &b);

scanf(""%f%3o",&a, &b);

浮点数类型定义宽度不能定义精度

%n用于接受一个unit，代表到%n为止所输入的字符数，其本省不消耗字符

u/o/x分别表示10/8/16进制的无符号数输入。

## 多态性

1（编译时）静态：函数重载、运算符重载、模板实现
2（运行时）动态: 虚函数实现

## 内联函数

在一个函数中，要求通过函数来实现一种不太复杂的功能，

并要求加快执行速度，选用内联函数

C++中建议内联函数替换宏函数（消除调用的时间空间开销）

使用内联函数的原因：

函数调用是时间和空间开销：入栈、出栈、跳转等开销。

如果函数体代码多，需要长时间执行，函数调用机制占用的时间可以忽略

但如果函数只有一两语句，大部分时间，都花费在函数调用机制上

开销就不容忽略

宏函数与内联函数的区别:

1.宏函数是在预处理期间进行处理的，只是简单的文本替换，在编译之前已经替换好了

2，内联函数在编译进行处理，具备普通函数的相应功能

参数检查 类型检查

注意事项：

1.函数体不能太庞大

2.不能有循环语句

3.不能有太复杂的条件判断语句

4.不能对内联函数进行去地址操作，因为编译完后的程序中不存在函数体

5.内联是一种请求，不一定能成功。


## 函数的形式参数隐含的存储类型是auto 

函数的隐含存储类型是extern 函数的形参或变量的存储类型为auto 

## 构造异质链表的意义

用抽象类指针构造派生类对象链表

实际中，很多场景都要用链表来管理不同类型的对象、节点，这样的链表叫作异质链表

如：如果将这些不同类型的对象用链表进行直接连接，显然不好操作，

但是可以抽象出这些对象的共同点，将这些共同点构造成节点，

然后把这些节点穿起来，并且需要保证这下节点，可以访问到对应的对象，也就是用抽象类指针构造派生类对象链表

## 多路复用I/O监听3个套接字的数据时， 如果套接字描述符分别是5,17， 19，则

select(int maxfd, struct fd_set* fd_set, NULL, NULL);

中maxfd应取为 20；

Maxfd要监视的文件描述符的范围，一般取监视描述符的最大值+1

## C++11 STL中的容器

一 顺序容器

vector: 可变大小数组

deque：双端队列

list: 双向链表

forward_list: 单向链表

array: 固定大小数组

string 与vector相似的容器，专门用于保字符

二 关联容器

按关键字有保存元素（底层实现为红黑树）

map:关联数组;保存关键字-值对

set:关键字即值，即只保存关键字的容器

multimap:关键字可重复的map

multiset:关键字可重复的set

无序集合：

unordered_map:用哈希函数组织的map

unordered_set: 用哈希函数组织的set

unordered_multimap: 哈希组织的map；关键字可以重复出现

unordered_multiset：哈希组织的set；关键字可以重复出现

其他

stack queue valarray bitset

## 基类中的成员在派生类中都是可以直接访问的 这是错误的

例如公有派生，子类只能访问父类的保护成员和公有成员，

父类的私有成员是不能被子类访问的

## calloc

void *calloc(unsigned n, unsigned size);

用calloc函数可以为一维数组开辟存储空间，n为元素个数，每个元素长度为size

函数返回值指向所分配域的起始位置的指针，如果分配不成功，则返回NULL;

## 凡是函数中未指定存储类别的局部变量，则隐含得存储类别为 auto 

函数中的局部变量，如果不专门声明为static存储类别，都是动态的分配存储空间，数据存在动态存储区中

这类变量叫做自动变量，自动变量可以用关键字auto 作为存储类别的声明，

实际上关键字auto 是可以省略的（一般都是不写的）不写则自动隐含为“自动存储类别”


## std::vector::iterator 没有重载下面那个运算符？

对于std::vector::iterator

1. ++ -- 用于双向迭代，迭代器最基本的功能
2. * 用于复引迭代器，用于引用迭代器对应的元素，也是基本操作
3. == 用于判断两个迭代器是否相等，迭代的时候需要判断迭代器是否到某个位置

## 在c语言中，形参的缺省存储类型是 auto 

一 数据的类型

1、常见的数据类型

2、存储类型 有自动变量 auto 静态变量 static 外部变量extern 寄存器变量 register

自动变量； 函数中所有的非静态局部变量

静态变量： 在变量前加上static 关键字的变量

外部变量： 一般用作全局变量作用域的扩展（还有定义在外部函数的时候前面也可以有一个extern 关键字

寄存器变量： 一般经常被使用的变量（如果一变量计算几千次）可以设置为

寄存器变量 register变量会被存储在寄存器中，计算速度远快于存在内存中

非 register变量

二 存储变量关乎着变量的作用域和生存时间

1 从作用域（空间）的角度来看

自动变量：其作用域仅仅局限于定义的函数中，存储在动态存储区，注意存储在动态存储区的数据

在没有显示初始化的时候，其变量的值的随机。

静态变量： 存储在静态存储区，静态变量包括静态全局变量和静态局部变量，静态

变量在没有显示初始化的时候会被初始化为0或null，并且只初始化一次（初始化不等于赋值）

静态全局变量：作用域只是在其定义的源文件中有效，对外部变量起到了屏蔽作用

静态局部变量：其作用域是其定义的函数中

外部变量：把全局变量在其他源文件中声明成extern 变量。可以扩展该全局变量的作用域至

声明的那个文件，其本质的作用就是对全局变量作用域的扩展

寄存器变量：存储在cpu的寄存器中，速度快，一般不需要程序员定义寄存器变量，这是由于一些编译器会把

需要参加很多次计算的 变量转化成及寄存器变量。不允许，程序员对寄存器变量的地址进行操作

2.从生存时间的角度来看：

自动变量：随着函数的进栈和出栈而创建和销毁

静态变量：长期存在静态存储区，直到程序结束

外部变量：长期存在静态存储区中，直到程序结束

寄存器变量：离开函数值就会消失

## 下列表达式选项中 正确的是

A ++(a++)

B a++b

C a+++b 正确

D a++++b

A错误 ，a++操作通过临时量返回其值，该值是一个常量，因此不能修改

不是左值，而后缀++需要对左值进行操作，所以会引起编译错误

**左值：可以被修改和引用的值，左值可以取地址，右值：在使用时，左值可以作为右值

但右值不能作为左值**


## DEBUG & RELEASE 

assert含义是断言，是标准C++的cassert头文件中定义的一个宏，用来判断

一个条件表达式的值是否为true,如果不为true 程序会终止。并且报告错误

这样很容易定位错误

通常开发程序由2中模式； Debug模式和release模式

1.在Debug模式下，编译器会记录很多调试信息，也可以加入很多测试代码，比如加入断言assert

方便程序员测试，以及出现bug时分析解决

2. Release模式下，就没有上述那些调试信息，而且编译器也会自动优化一些代码

这样生成的程序性能是最优的，如果出现问题，就不方便分析测试

## const 函数

c++ 的const 函数特点

1. 不能再const 函数中修改所在类的对象的数据，因为const 函数

中的 * this是常量，同样只能访问const函数

2、const 函数中只能调用其他const函数，不能调用非const函数，因为对象调用函数需要

传递对象自己，const函数中 * this 是常量，非 const 函数中 * this 是变量。

因此不可以调用（除非取出 * this 属性)

Note: 使用const_cast 后，可以在const 函数中调用非const函数的

3. const函数与同名的非const函数是重载函数

4. const 对象只能调用const函数，但是非const对象可以调用const函数

## 关于函数模板，描述错误的是

a 函数模板必须由程序员实例化为可执行的函数模板

b 函数模板的实例化由编译器实现

c 一个类定义中，只要有一个函数模板，这个类就是类模板

d 类模板的成员函数都是函数模板。类模板实例化后，成员函数也随机实例化

A 错误 函数模板必须由编译器根据程序员的调用类型实例化为可执行的函数

B 正确 函数模板和类模板的实例化都是由编译器实现的

C 错误 类模板中的成员函数都是函数模板

D 错误 类模板实例化后，没有用的成员函数没有实例化

函数模板是C++新增的一种性质，它允许只定义一次函数的实现，即可使用不同类型的参数来调用该函数

这样做可以减小代码的书写的复杂度，同时也便于修改，但是在代码中包含函数模板

本省并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器

使用模板为特定类型生成函数定义时。 得到的是模板实例。

## 以下 关于抽象类的说法正确的是

A 抽象类只能用作其他类的基类

B 不能使用抽象类定义对象

C 抽象类不能用作参数类型、函数返回类型或显示转换的类型

D 抽象类不能有构造函数的析构函数

抽象类需要注意：

1. 抽象类只能作为其他类的基类，他不能直接被实例化， 而且对抽象类不能使用new 操作符

抽象类中如果函数变量或值， 则他们一定是Null类， 要么包含了对非抽象类的的实例的引用

2. 抽象类允许包含抽象成员，但这不是必须的； 抽象类中可以有非抽象方法

3. 如果一个非抽象类从抽象类中派生，则其必须通过覆盖来实现所有的继承而来的抽象成员

4. 抽象类可以被抽象类所继承，结果依然是抽象类

5. 抽象类允许被声明


## 关于static用途说法正确的是 BCD

A 声明静态外部类

B 声明静态全局变量

C 声明静态函数

D 声明静态局部变量

1. 设置静态局不变量，变量只定义一次，不能被别的函数使用

2. 设置静态全局变量，变量不能被外部文件所使用

3. 在类中设置静态函数，只能访问静态变量


## 多态类中的虚函数表建立在 编译阶段 ??


## c语言中保留字

## 关于位运算

位运算的对象只能是整型或字符类型数据

## 结构体 struct






























































































































































































































































































